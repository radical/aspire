name: Quarantine/Disable Test

on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  quarantine_test:
    if: >-
      (
        contains(github.event.comment.body, '/quarantine-test') ||
        contains(github.event.comment.body, '/unquarantine-test') ||
        contains(github.event.comment.body, '/disable-test') ||
        contains(github.event.comment.body, '/enable-test')
      )
    runs-on: ubuntu-latest
    steps:
    - name: Extract command and arguments
      uses: actions/github-script@v7
      id: extract-command
      with:
        result-encoding: string
        script: |
          const body = context.payload.comment.body;

          // Helper to fail with an error message that can be captured
          function failWithError(message) {
            core.setOutput('error_message', message);
            core.setFailed(message);
          }

          // Define command patterns with their configurations
          const commands = [
            { pattern: /^\/quarantine-test\s+(.+)$/m, action: 'quarantine', mode: 'quarantine', requiresUrl: true },
            { pattern: /^\/unquarantine-test\s+(.+)$/m, action: 'unquarantine', mode: 'quarantine', requiresUrl: false },
            { pattern: /^\/disable-test\s+(.+)$/m, action: 'quarantine', mode: 'activeissue', requiresUrl: true },
            { pattern: /^\/enable-test\s+(.+)$/m, action: 'unquarantine', mode: 'activeissue', requiresUrl: false }
          ];

          let matched = null;
          let args = null;

          for (const cmd of commands) {
            const match = cmd.pattern.exec(body);
            if (match) {
              matched = cmd;
              args = match[1].trim();
              break;
            }
          }

          if (!matched) {
            failWithError('No valid command found. Use /quarantine-test, /unquarantine-test, /disable-test, or /enable-test');
            return;
          }

          // Parse arguments: for quarantine/disable, last argument should be URL
          const parts = args.split(/\s+/).filter(p => p.length > 0);

          if (parts.length === 0) {
            failWithError('No test name(s) provided.');
            return;
          }

          let testNames = [];
          let issueUrl = '';

          if (matched.requiresUrl) {
            if (parts.length < 2) {
              failWithError(`${matched.action === 'quarantine' && matched.mode === 'quarantine' ? '/quarantine-test' : '/disable-test'} requires at least one test name and an issue URL.`);
              return;
            }

            // Last part should be the URL
            const potentialUrl = parts[parts.length - 1];

            // Validate URL
            const urlPattern = /^https?:\/\/.+/i;
            if (!urlPattern.test(potentialUrl)) {
              failWithError(`Invalid issue URL: "${potentialUrl}". Must be a valid http/https URL.`);
              return;
            }

            issueUrl = potentialUrl;
            testNames = parts.slice(0, -1);
          } else {
            testNames = parts;
          }

          // Validate test names (should look like Namespace.Type.Method)
          const testNamePattern = /^[A-Za-z_][A-Za-z0-9_]*(\.[A-Za-z_][A-Za-z0-9_]*)*(\+[A-Za-z_][A-Za-z0-9_]*)*(\.[A-Za-z_][A-Za-z0-9_]*)+$/;
          for (const testName of testNames) {
            if (!testNamePattern.test(testName)) {
              failWithError(`Invalid test name format: "${testName}". Expected format: Namespace.Type.Method`);
              return;
            }
          }

          // Determine human-readable action name for PR title
          let actionVerb;
          if (matched.action === 'quarantine') {
            actionVerb = matched.mode === 'quarantine' ? 'Quarantine' : 'Disable';
          } else {
            actionVerb = matched.mode === 'quarantine' ? 'Unquarantine' : 'Enable';
          }

          const result = {
            action: matched.action,
            mode: matched.mode,
            testNames: testNames,
            issueUrl: issueUrl,
            actionVerb: actionVerb
          };

          console.log('Parsed command:', JSON.stringify(result, null, 2));

          core.setOutput('action', result.action);
          core.setOutput('mode', result.mode);
          core.setOutput('test_names', testNames.join(' '));
          core.setOutput('issue_url', issueUrl);
          core.setOutput('action_verb', actionVerb);

          return 'success';

    - name: Verify user has write access
      uses: actions/github-script@v7
      with:
        script: |
          const comment_user = context.payload.comment.user.login;

          try {
            const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              username: comment_user
            });

            const writePermissions = ['admin', 'write'];
            if (!writePermissions.includes(permission.permission)) {
              core.setFailed(`@${comment_user} does not have write access to this repo. Required permissions: write or admin.`);
              return;
            }

            console.log(`Verified ${comment_user} has ${permission.permission} access to the repo.`);
          } catch (error) {
            core.setFailed(`Error checking permissions for @${comment_user}: ${error.message}`);
          }

    - name: Post started comment
      uses: actions/github-script@v7
      with:
        script: |
          const actionVerb = '${{ steps.extract-command.outputs.action_verb }}';
          const testNames = '${{ steps.extract-command.outputs.test_names }}'.split(' ');
          const workflow_run_url = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

          const testList = testNames.map(t => `\`${t}\``).join(', ');
          const body = `⏳ Started ${actionVerb.toLowerCase()} operation for ${testList}... ([workflow run](${workflow_run_url}))`;

          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });

    - name: Checkout repo
      uses: actions/checkout@v4
      with:
        ref: main
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Run QuarantineTools
      id: run-tool
      shell: bash
      env:
        ACTION: ${{ steps.extract-command.outputs.action }}
        MODE: ${{ steps.extract-command.outputs.mode }}
        TEST_NAMES: ${{ steps.extract-command.outputs.test_names }}
        ISSUE_URL: ${{ steps.extract-command.outputs.issue_url }}
      run: |
        # Build the command
        if [ "$ACTION" = "quarantine" ]; then
          FLAG="-q"
        else
          FLAG="-u"
        fi

        # Run the tool and capture output
        echo "Running: dotnet run --project tools/QuarantineTools -- $FLAG -m $MODE -i \"$ISSUE_URL\" $TEST_NAMES"

        set +e
        if [ "$ACTION" = "quarantine" ]; then
          OUTPUT=$(dotnet run --project tools/QuarantineTools -- $FLAG -m "$MODE" -i "$ISSUE_URL" $TEST_NAMES 2>&1)
        else
          OUTPUT=$(dotnet run --project tools/QuarantineTools -- $FLAG -m "$MODE" $TEST_NAMES 2>&1)
        fi
        EXIT_CODE=$?
        set -e

        echo "$OUTPUT"

        # Save output for failure comment (escape for GitHub Actions)
        EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
        echo "tool_output<<$EOF" >> $GITHUB_OUTPUT
        echo "$OUTPUT" >> $GITHUB_OUTPUT
        echo "$EOF" >> $GITHUB_OUTPUT

        exit $EXIT_CODE

    - name: Check for changes
      id: check-changes
      run: |
        if git diff --quiet; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
        else
          echo "has_changes=true" >> $GITHUB_OUTPUT
          git diff --name-only
        fi

    - name: Create Pull Request
      if: steps.check-changes.outputs.has_changes == 'true'
      uses: actions/github-script@v7
      env:
        ACTION_VERB: ${{ steps.extract-command.outputs.action_verb }}
        TEST_NAMES: ${{ steps.extract-command.outputs.test_names }}
        ISSUE_URL: ${{ steps.extract-command.outputs.issue_url }}
        MODE: ${{ steps.extract-command.outputs.mode }}
      with:
        script: |
          const { execSync } = require('child_process');

          const actionVerb = process.env.ACTION_VERB;
          const testNames = process.env.TEST_NAMES.split(' ');
          const issueUrl = process.env.ISSUE_URL;
          const mode = process.env.MODE;
          const comment_user = context.payload.comment.user.login;
          const issue_number = context.issue.number;

          // Create branch name
          const timestamp = Date.now();
          const branchName = `automated/${actionVerb.toLowerCase()}-test-${timestamp}`;

          // Configure git
          execSync('git config user.name "github-actions"');
          execSync('git config user.email "github-actions@github.com"');

          // Create and checkout branch
          execSync(`git checkout -b ${branchName}`);

          // Stage and commit changes
          execSync('git add -A');

          const testList = testNames.length === 1 ? testNames[0] : `${testNames.length} tests`;
          const commitMessage = `[automated] ${actionVerb} ${testList}`;
          execSync(`git commit -m "${commitMessage}"`);

          // Push branch
          execSync(`git push origin ${branchName}`);

          // Create PR description
          const testListFormatted = testNames.map(t => `- \`${t}\``).join('\n');
          const issueRef = issueUrl ? `\n\nRelated issue: ${issueUrl}` : '';
          const triggerRef = `\n\nTriggered by: #${issue_number} (comment by @${comment_user})`;
          const attributeType = mode === 'quarantine' ? 'QuarantinedTest' : 'ActiveIssue';

          const prBody = `## ${actionVerb} Test(s)

          This PR was automatically generated to ${actionVerb.toLowerCase()} the following test(s) using the \`${attributeType}\` attribute:

          ${testListFormatted}
          ${issueRef}${triggerRef}

          ---
          ⚠️ Please review the changes before merging.`;

          // Create PR
          const { data: pr } = await github.rest.pulls.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `[automated] ${actionVerb} ${testList}`,
            body: prBody,
            head: branchName,
            base: 'main'
          });

          console.log(`Created PR #${pr.number}: ${pr.html_url}`);

          // Add label
          try {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['automated']
            });
          } catch (labelError) {
            console.log(`Note: Could not add label: ${labelError.message}`);
          }

          // Post success comment
          const successBody = `✅ ${actionVerb} operation completed! Created PR #${pr.number}: ${pr.html_url}`;
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: successBody
          });

    - name: Post no-changes comment
      if: steps.check-changes.outputs.has_changes == 'false'
      uses: actions/github-script@v7
      with:
        script: |
          const actionVerb = '${{ steps.extract-command.outputs.action_verb }}';
          const body = `ℹ️ No changes were needed. The test(s) may already be in the desired state.`;

          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });

    - name: Post failure comment
      if: failure()
      uses: actions/github-script@v7
      with:
        script: |
          const workflow_run_url = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
          const actionVerb = process.env.ACTION_VERB || 'Operation';
          const toolOutput = process.env.TOOL_OUTPUT || '';
          const extractError = process.env.EXTRACT_ERROR || '';

          let body = `❌ ${actionVerb} failed.\n\n`;

          // Check for extract step error first
          if (extractError) {
            body += `**Error:** ${extractError}\n\n`;
          } else if (toolOutput) {
            // Extract just the error lines (skip build output)
            const lines = toolOutput.split('\n');
            const errorLines = lines.filter(line =>
              line.includes('Error') ||
              line.includes('error') ||
              line.includes('No method found') ||
              line.includes('failed') ||
              line.includes('Invalid')
            ).slice(0, 10);  // Limit to 10 error lines

            if (errorLines.length > 0) {
              body += `**Error:**\n\`\`\`\n${errorLines.join('\n')}\n\`\`\`\n\n`;
            }
          }

          body += `See the [workflow run](${workflow_run_url}) for full details.`;

          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });
      env:
        ACTION_VERB: ${{ steps.extract-command.outputs.action_verb }}
        TOOL_OUTPUT: ${{ steps.run-tool.outputs.tool_output }}
        EXTRACT_ERROR: ${{ steps.extract-command.outputs.error_message }}
